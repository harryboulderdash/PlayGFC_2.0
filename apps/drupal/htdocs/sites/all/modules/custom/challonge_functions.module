<?php
/**
 * Function Description
 * @param function_parameter
 * @returns function output description
 */

/**
 * Log and display the error
 * @param string $error Error to report
 * @param object/array $object Object to include with the log
 * @param bool $backtrace TRUE if watchdog log should include full backtrace of the error
 */
function _watchdog_log($error, $object = NULL, $backtrace = FALSE) {
    $object_msg = $object ? 'Object: ' . var_export($object, TRUE) : '';
    $bt = $backtrace ? 'Backtrace: ' . var_export(debug_backtrace(), TRUE) : '';
    watchdog('GFC:challonge_functions', "Error message: %error<br>\n%object<br>\n%bt", array('%error' => $error, '%object' => $object_msg, '%bt' => $bt), WATCHDOG_ERROR);
    /*$last_id = db_query("SELECT 1", array(), array('return' => Database::RETURN_INSERT_ID));
    $msg = t("Error: !id", array('!id' => $last_id));
    $err_msg = user_access('access site reports') ? l($msg, 'admin/reports/event/' . $last_id) : $msg;
    drupal_set_message($err_msg, 'error');*/
}

//CONSTANTS

//Taxon IDs
define('CAPTAIN_ROLE', '69');
define('MEMBER_REMOVED_STATUS','112');


function createGFCTournament($mynodeidparent) {
    include_once DRUPAL_ROOT . '/includes/challonge.class.php';


    // /********************************************************************************
    // //CREATE A TOURNAMENT and Update Drupal Tournaments Node with Challonge tourney ID
    //

    // Include the Challonge API Class
    //include('/opt/bitnami/apps/drupal/htdocs/includes/challonge.class.php');
    $c = new ChallongeAPI('XqrMnBPs15MvmX0izddB4zyIHKswRCoaIAyq4cTt');

    // get the GFC data needed to create tourney in Challonge
    //$mynodeidparent = 5; //test id for debugging
    $node = node_load($mynodeidparent);
    $wrapper = entity_metadata_wrapper('node',$node);

    // retreive param values needed from GFC data

    // get tourney name
    $tourney_name = $wrapper->field_tournament_name->value();

    // get type of play
    $term = taxonomy_term_load ( $wrapper->field_tournament_type->raw());
    $wrapper2 = entity_metadata_wrapper('taxonomy_term',$term);
    $tourney_type = $term->name;

    // get description
    $tourney_descriptions = $wrapper->field_tournament_description->value ();

    //get url value
    $tourney_url = (string)uniqid('tid'); //str_replace ( ' ', '', $tourney_name ); // TODO: invent good url scheme

    // set paramater values for challonge from GFC values
    $params = array (
        "tournament[name]" => $tourney_name,
        "tournament[tournament_type]" => $tourney_type, // see if this can be dynamic
        "tournament[url]" => $tourney_url,
        "tournament[description]" => $tourney_descriptions
    );

    // call to challonge to create tournament
    $tournament = $c->makeCall ("tournaments",$params,"post");
    $tournament = $c->createTournament($params);

    //Save new URL value to GFC
    $wrapper->field_tournament_challonge_url->set($tourney_url);
    // save value
    $wrapper->save();

    // *************************
    // update GFC with returned tournament ID
    // *************************

    //****************NOTE: Need to reload by URL value from CHALLONGE due to bug
    $tournament_id = $tourney_url;
    $params = array("include_matches " => 0);
    $tournament = $c->makeCall("tournaments/$tournament_id", $params, "get");
    $tournament = $c->getTournament($tournament_id, $params);


    // retreive new tournament id and set to variable
    $challonge_id = (integer)$tournament->id;

    // id set value
    $wrapper->field_tournament_challonge_id->set($challonge_id);
    //set url value

    // save value
    $wrapper->save();

    //debug logging
    _watchdog_log('Challonge Response creating new tournament: ' . $tourney_name,$c->result);

    return $c->result;

}

function getTeamStatus($teamNID,$tournamentid){

    /*
     * TODO:these items
     * Check each player for accepting participation
     * Check each player for adequate credits
     * Insure gamertags are all valid
     * any other rules I am forgetting
     *
     * return either a string of problems
     * optionally, these could be constants,
     * or could create content type with the error messages, colors, etc.
     *
     * TODO:consider if this should validate all teams as a collection
     *
     * */
}

function StartTournament_Validate($tournamentid){

    /*
     * TODO: complete this mess of logic
     * TODO: call the getTeamStatus() function to complete team checks.
     * Check for any teams that are not validated
     * 1. If not 'green' then remove that team from tournament
     * 2. We won't actually remove the credits until the tournament starts
     * so, need a way to earmark the credits but make it reversible.
     *
     * So, to do this we need:
     * Bank_Ledger
     * UID
     * tournamentID
     * tran_date
     * tran_type (such as credits flaged for tournament with ID=, credits purchase, credits debit, prize credits awarded....)
     * money_type (currency, credits)
     * currency_type (UDS, GPB)
     * tran_amount
     * IP_Address or requester
     * Gateway_message
     *
     *
     *
     * */
}

function StartTournament($tournamentid){

    //check in tournament
    //get team and match info and update GFC
    //start tournament
    /*
     * TODO:call the StartTournamentValidate function to prep all the data for a proper start.
     * TODO: if there are not a minimum # of teams, deal with it somehow
     * TODO: Jacob, how to handle that scenario??
     *
     *
     * */

    try {
        include_once DRUPAL_ROOT . '/includes/challonge.class.php';

        //set for debug
        //$tournamentid = 211;

        //debug elapsed time
        $start = microtime(true);

        $c = new ChallongeAPI('XqrMnBPs15MvmX0izddB4zyIHKswRCoaIAyq4cTt');

        //load up GFC tourney data
        $tourneywrapper = GetWrapperByEntityID($tournamentid);
        //$node = node_load($tournamentid);
        //$tourneywrapper = entity_metadata_wrapper('node',$node);

        $challongeid = $tourneywrapper->field_tournament_challonge_id->value();

        //***************************************************************
        //Set variables for setting maps on each match
        //get best of value in variable to determine num of maps needed
        $bestOfNumber = $tourneywrapper->field_tournament_best_of->value();

        //get game title value for call to get maps
        $gameTitle = $tourneywrapper->field_tournament_game_type->value()->vid;

        //get game mode value for call to get maps
        $gameMode = $tourneywrapper->field_tournament_game_modes->value()->tid;

        //call function to get all maps for the tourney title and mode and store in array
        $arrMaps = getMapsByTitleAndMode($gameTitle, $gameMode);
        //****************************************************************

        //STEP 1 -- PUBLISH TOURNEY***********************

        // Publish a tournament -- WORKS!
        // http://challonge.com/api/tournaments/publish/:tournament
        //$tournament_id = $tournamentid;
        $params = array();
        $tournament = $c->makeCall("tournaments/publish/$challongeid", $params, "post");
        $tournament = $c->publishTournament($challongeid, $params);

        //step 1.5 randomize seeds
        $params = array();
        $participants = $c->makeCall("tournaments/$challongeid/participants/randomize", array(), "post");
        $tournament = $c->randomizeParticipants($challongeid, $params);


        //STEP 2 -- START TOURNEY***********************

        // Start a tournament -- WORKS!
        // http://challonge.com/api/tournaments/start/:tournament
        $params = array();
        $tournament = $c->makeCall("tournaments/start/$challongeid", $params, "post");
        $tournament = $c->startTournament($challongeid, $params);


        //STEP 3 --UPDATE TEAMS WITH CHALLONGE TEAM IDs***********************

        // Get all participants -- WORKS!
        // http://challonge.com/api/tournaments/:tournament/participants
        $participants = $c->makeCall("tournaments/$challongeid/participants");
        $participants = $c->getParticipants($challongeid);

        //log response
        _watchdog_log('Challonge respsonse getting participants for tourney: ' . $challongeid, print_r($c));

        // retrieve param values needed from GFC data
        //iterate through team gfc node ids
        foreach ($tourneywrapper->field_tournament_teams_entered->getIterator() as $delta => $team) {

            //set variable to team name
            $teamname = $team->field_team_id->value();

            //update GFC teams with IDs
            foreach ($participants as $participant) {

                if (str_replace(' ', '', $participant->misc) == str_replace(' ', '', $teamname)) {
                    //if team matches name get id and update
                    $team->field_team_challonge_id->set((integer)$participant->id);
                    $team->save();
                }

            }
        }

        /*
        STEP 4 -- CREATE MATCHES IN GFC***********************
        */

        //Get all Matches from CHALLONGE-- WORKS!
        $params = array();
        $matches = $c->makeCall("tournaments/$challongeid/matches", $params);
        $matches = $c->getMatches($challongeid, $params);


        //Create corresponding GFC matches and set players, maps and hosts
        foreach ($matches as $match) {

            $values = array(
                'type' => 'match',
                'uid' => 1,
                'status' => 1,
                'comment' => 1,
                'promote' => 0,
            );

            //create match entity and wrap it
            $matchentity = entity_create('node', $values);
            $emw = entity_metadata_wrapper('node', $matchentity);

            //debug elapsed time
            _watchdog_log('new match created: ' . (microtime(true) - $start));
            //****************************************************************

            //set field values
            $emw->field_match_challonge_id->set((integer)$match->id);
            $emw->field_match_round->set((integer)$match->round);
            $emw->title->set($tourneywrapper->field_tournament_name->value() . "_" . (string)$match->id);
            //save the match updates
            $emw->save();

            /*
             * ADD NEW MATCH TO TOURNAMENT ENTITY
             * */
            $tourneywrapper->field_tournament_match[] = $emw->nid->value();
            //save it
            $tourneywrapper->save();

            //debug elapsed time
            _watchdog_log('NEW MATCH CREATED: ' . (microtime(true) - $start));


            /*
             *
             * COULD THIS BE SHARED CODE AFTER THIS POINT?
             *
             * */
            //run update for all matches to get tea

            //clear team id's for matches
            //where participants are not yet known.
            //flush out variables
            unset($emw);
            unset($query);
            unset($query2);
            unset($result);
            unset($result2);
            $team1 = 0;
            $team2 = 0;

        }

       // Set Teams for ACTIVE MATCHES
        UpdateMatchesDataFromAPI($tournamentid);

        //Finally, set the tourney to started now that all matches are setup
        $tourneywrapper->field_tournament_status->set("Started");

        // save value
        $tourneywrapper->save();

        //if we made it here return true for sucess
        return true;
    }
    catch
        (EntityMetadataWrapperException $exc) {
            _watchdog_log($exc->getMessage(), $exc);
    }

}

/**
 * @param $tournament_id
 * @return bool
 */
function UpdateMatchesDataFromAPI($tournament_id)
{
    //This function loads the Challonge API matches data for a tourney
    //and refreshes the match data in GFC
    //so as rounds complete
    //the new round team values are updated in GFC data
    //this should be called as each match result is added
    try{
        include_once DRUPAL_ROOT . '/includes/challonge.class.php';

        $c = new ChallongeAPI('XqrMnBPs15MvmX0izddB4zyIHKswRCoaIAyq4cTt');

        //debug elapsed time
        $start = microtime(true);

        //load up tourney data
        $wrapper_t = GetWrapperByEntityID($tournament_id);

        //***************************************************************
        //Set variables for setting maps on each match
        //get best of value in variable to determine num of maps needed
        $bestOfNumber = $wrapper_t->field_tournament_best_of->value();

        //get game title value for call to get maps
        $gameTitle = $wrapper_t->field_tournament_game_type->value()->vid;

        //get game mode value for call to get maps
        $gameMode = $wrapper_t->field_tournament_game_modes->value()->tid;

        //call function to get all maps for the tourney title and mode and store in array
        $arrMaps = getMapsByTitleAndMode($gameTitle, $gameMode);

        //****************************************************************************

        //get API tourney ID for remote calls
        $challongeid = $wrapper_t->field_tournament_challonge_id->value();

        //Get all Matches -- WORKS!
        $params = array();
        $matches = $c->makeCall("tournaments/$challongeid/matches", $params);
        $matches = $c->getMatches($challongeid, $params);

        foreach ($matches as $match) {

            /*
             * ***********************
             * START ITERATING THROUGH MATCHES 'WITH TEAMS ONLY' TO DO GFC UPDATES
             * ***********************
             * */

            if ((integer)$match->{'player1-id'} != 0 && (integer)$match->{'player2-id'} != 0) {

                /*
                ************************
                * STEP #1
                * BEGIN LOAD AND WRAP GFC MATCH ENTITY
                *
                * WORK PRODUCT HERE IS THE $emw OJECT
                * ***********************
                * */

                //find and load corresponding GFC match entity
                // and create an object from it
                $query3 = new EntityFieldQuery();

                //QUERY FOR MATCH BY MATCH CHALLONGE ID
                $query3->entityCondition('entity_type', 'node')
                    ->entityCondition('bundle', 'match')
                    ->fieldCondition('field_match_challonge_id', 'value', (integer)$match->{'id'}, '=')
                    ->addMetaData('account', user_load(1)); // Run the query as user 1.

                //fire off search for corresponding GFC match
                $result3 = $query3->execute();

                //WRAP MATCH IN EMW WRAPPER FOR LATER USE
                //Put match found into object so we can set its values
                if (isset($result3['node'])) {
                    $nodes3 = entity_load('node', array_keys($result3['node']));
                    foreach ($nodes3 as $node3) {
                        $emw = GetWrapperByEntityID($node3->nid);
                    }
                    unset($nodes3);
                }

                /*
                  ************************
                  * END STEP 1 LOAD AND WRAP GFC MATCH ENTITY
                  ************************
                  * */


                /*
                 * ***********************
                 * STEP #2 LOAD GFC TEAM OBJECTS
                 ************************
                 *
                 *
                 *
                 * WHY BOTHER??
                 * ANSWER: BECAUSE I NEED THE NAMES TO SET THE HOSTS
                 * AND ALSO USE THE TEAM NID TO ADD TO MATCH
                 *
                 * */

                //get corresponding team nids value from GFC team
                //and update GFC match with who the teams are
                //for TEAM 1
                $query = new EntityFieldQuery();

                $query->entityCondition('entity_type', 'node')
                    ->entityCondition('bundle', 'team')
                    ->fieldCondition('field_team_challonge_id', 'value', (integer)$match->{'player1-id'}, '=')
                    ->addMetaData('account', user_load(1)); // Run the query as user 1.

                $result = $query->execute();

                //get team 1 name
                if (isset($result['node'])) {
                    $nodes = entity_load('node', array_keys($result['node']));
                    foreach ($nodes as $node) {
                        $team1 = $node->nid;
                        $emwTeam1 = entity_metadata_wrapper('node', $node);
                        $team1Name = $emwTeam1->field_team_name->value();
                        unset($emwTeam1);
                        unset($nodes);
                    }
                }

                //get corresponding team nids value from GFC team
                //and update GFC match with who the teams are
                //for TEAM 2
                $query2 = new EntityFieldQuery();

                $query2->entityCondition('entity_type', 'node')
                    ->entityCondition('bundle', 'team')
                    ->fieldCondition('field_team_challonge_id', 'value', (integer)$match->{'player2-id'}, '=')
                    ->addMetaData('account', user_load(1)); // Run the query as user 1.

                $result2 = $query2->execute();

                //get team 2 name
                if (isset($result2['node'])) {
                    $nodes2 = entity_load('node', array_keys($result2['node']));
                    foreach ($nodes2 as $node2) {
                        $team2 = $node2->nid;
                        $emwTeam2 = entity_metadata_wrapper('node', $node);
                        $team2Name = $emwTeam2->field_team_name->value();
                        unset($emwTeam2);
                    }
                    unset($nodes2);
                }

                /*
               ************************
               *END STEP 2 TO LOAD NAME & ID OF EACH TEAM FROM TEAM OBJECT
               ************************
               * */

                //debug elapsed time*****************************************************
                _watchdog_log('TEAMS '.$team1Name . ' AND '. $team2Name .' LOOKED UP: ' . (microtime(true) - $start));
                //debug elapsed time*****************************************************


                /************************
                 * STEP 3 -- Add in the match MAPS and HOSTS***********************
                 ************************
                 *
                 * this is safe to do since this match has teams in it now
                 *
                */

                //create variable for maps csv
                $mapsCSV = '';
                $hostsCSV = '';

                //iteriate through maps & hosts based on number needed
                // to build csv string of maps/rounds for this match
                for ($i = 1; $i <= $bestOfNumber; $i++) {
                    //Set the maps
                    // If the history array is empty, re-populate it.
                    if (empty($arr_history)) {
                        $arr_history = $arrMaps;
                    }

                    // Randomize the array.
                    shuffle($arr_history);

                    // Select the last value from the array.
                    $selectedMap = array_pop($arr_history);

                    // create csv string here for match value
                    $mapsCSV .= t($selectedMap);


                    // create csv string here for match value
                    // use odd & even to order team precedence
                    if ($i % 2 == 0) {
                        //even maps go to 2nd seed;
                        $hostsCSV .= $team2Name;
                    } else {
                        //odd maps go to 1st seed
                        $hostsCSV .= $team1Name;
                    }

                    //if not the last map add a comma
                    //to maps file
                    //and to hosts file
                    if ($i != $bestOfNumber) {
                        $hostsCSV .= ',';
                        $mapsCSV .= ',';
                    }
                }

                /*
                 ************************
                 * END STEP 3 -- ADDING MAPS and HOSTS
                 ************************
                */

                /************************
                 * SET ALL THE MATCH VALUES AND SAVE THEM
                 ************************
                 * */

                $emw->field_match_team_1->set((integer)$team1);
                $emw->field_match_team_2->set((integer)$team2);

                //TODO: ONLY DO THIS IF WAS PENDING PRIOR ROUND

                if($emw->field_match_status->value() == "Pending Prior Round"){
                    $emw->field_match_status->set("Ready For Play");
                }


                //add teams to teams field to match so they are
                // all in one place for convenient reads.
                //field_match_teams_all
                /*
                 * TODO: CLEAR THIS FIELD BEFORE ADDING CURRENT TEAMS BACK IN
                 * */

                //TODO: does this work to clear old values?
               // $emw->field_match_teams_all[] = array();


                $emw->field_match_teams_all[] = (integer)$team1;
                $emw->field_match_teams_all[] = (integer)$team2;

                //field_match_mapsâ€Ž
                $emw->field_match_maps->set((string)$mapsCSV);
                $emw->field_match_host_order->set((string)$hostsCSV);

                //save the match updates
                $emw->save();


                //debug elapsed time*****************************************************
                _watchdog_log('MATCH UPDATED: '. $match->{'suggested-play-order'} . ' ID-' . $emw->field_match_challonge_id->value() . ' WITH TEAMS' . $team1Name . ' and '. $team2Name . ' at: ' . (microtime(true) - $start));
                //debug elapsed time*****************************************************

                //some clean up
                unset($team1);
                unset($team2);
                unset($emw);
                unset($query3);
                unset($result3);
            }
            /*
             * ***********************
             * END ITERATING THROUGH MATCHES WITH TEAMS TO DO GFC UPDATES
             * ***********************
             * */

        }

        //if we made it here return true for sucess
        return true;

    }
    catch (EntityMetadataWrapperException $exc) {
        _watchdog_log($exc->getMessage(),$exc);
    }
}

function UpdateMatchResult($tournament_id, $match_id, $team_1_score, $team_2_score, $isDisputed = 0){
    include_once DRUPAL_ROOT . '/includes/challonge.class.php';

    //TODO: Capture info about the user reporting the scores.
    //UpdateMatchResult(30,35,2,1,31);

    try {
        //set to false until success
        $return = false;

        //instantiate challonge class
        $c = new ChallongeAPI('XqrMnBPs15MvmX0izddB4zyIHKswRCoaIAyq4cTt');

        //Load and update match team scores
        $w_match = GetWrapperByEntityID($match_id);

        //decide winner based on highest score
        //assumes no tie is possible
        //if a tie is possible, this needs to change!
        if ($team_1_score > $team_2_score) {
            $w_match->field_match_winner->set($w_match->field_match_team_1->nid->value());
        } else {
            $w_match->field_match_winner->set($w_match->field_match_team_2->nid->value());
        }

        //set team scores
        $w_match->field_match_team_1_score->set($team_1_score);
        $w_match->field_match_team_2_score->set($team_2_score);

        //Set status depending on if match result is in dispute
        if ($isDisputed != 0){
            $w_match->field_match_disputed->set(1);
            $w_match->field_match_status->set("Disputed Result");
        }
        else{
            $w_match->field_match_status->set("Scores Reported");
        }

        //update status
        $w_match->field_match_status->set("Scores Reported");

        $w_match->save();

        //Get Challonge IDs for external updates
        $challongeid_m =  $w_match->field_match_challonge_id->value();
        $challongeid = GetWrapperByEntityID($tournament_id)->field_tournament_challonge_id->value();

        //prep param values for Challonge
        $scores =  $team_1_score . "-" . $team_2_score;
        $params = array(
            "match[scores_csv]" => $scores,
            "match[winner_id]" => $w_match->field_match_winner->field_team_challonge_id->value()  //$winnerid
        );
        //execute calls to Challonge API
        $match = $c->makeCall("tournaments/$challongeid/matches/$challongeid_m", $params, "put");
        $match = $c->updateMatch($challongeid, $challongeid_m, $params);

        //log response
        _watchdog_log('Challonge response:', $c->result);

        //run update for all matches to get team assignments for next round
        UpdateMatchesDataFromAPI($tournament_id);

        return true;

    }
    catch (EntityMetadataWrapperException $exc) {
        _watchdog_log($exc->getMessage(),$exc);
    }

}

function GetWrapperByEntityID($nid){

    //make updates to GFC data first
    //$node = node_load($nid);
    $wrapper = entity_metadata_wrapper('node',$nid);

    return $wrapper;
}

function getTournamentNodeIDByChallongeID($challongeTID){
    //get NID from Challonge tourney ID
    $tournamentNID = '';

    $query = new EntityFieldQuery();

    $query->entityCondition('entity_type', 'node')
        ->entityCondition('bundle', 'tournaments')
        ->fieldCondition('field_tournament_challonge_url', 'value', $challongeTID, '=')
        ->addMetaData('account', user_load(1)); // Run the query as user 1.

    $result = $query->execute();


    if (isset($result['node'])) {
        $nodes = entity_load('node', array_keys($result['node']));
        foreach ($nodes as $node) {
            $tournamentNID =  $node->nid;
        }
    }

    return $tournamentNID;
}

function getMatchNodeIDByChallongeID($challongeMID){
    //get NID from Challonge tourney ID

    $query = new EntityFieldQuery();

    $query->entityCondition('entity_type', 'node')
        ->entityCondition('bundle', 'match')
        ->fieldCondition('field_match_challonge_id', 'value', $challongeMID, '=')
        ->addMetaData('account', user_load(1)); // Run the query as user 1.

    $result = $query->execute();


    if (isset($result['node'])) {
        $nodes = entity_load('node', array_keys($result['node']));
        foreach ($nodes as $node) {
            $matchNID =  $node->nid;
        }
    }

    return $matchNID;
}

function getExistingTeamsByUser($currentUser){

    $currentUserID = $currentUser->uid;
    $userTeams = array();
    //team_members
    //field_team_member_user
    //field_team_reference_from_team_m

    $query = new EntityFieldQuery();

    $query->entityCondition('entity_type', 'team_members')
        ->entityCondition('bundle', 'team_members')
        ->fieldCondition('field_team_member_user', 'target_id', $currentUserID, '=')
        //  ->fieldCondition('field_marketer', 'target_id', $user->uid, '=');

        ->addMetaData('account', user_load(1)); // Run the query as user 1.

    $result = $query->execute();


    if (isset($result['team_members'])) {
        $teams = entity_load('team_members', array_keys($result['team_members']));

        //dpm($teams);
        foreach ($teams as $team) {
            //dpm($team);
            $userTeams[$team->field_team_reference_from_team_m['und'][0]['target_id']] =  GetWrapperByEntityID($team->field_team_reference_from_team_m['und'][0]['target_id'])->field_team_name->value();
        }
    }

    return $userTeams;

}

function getPlayerRoles(){
    try{
        //
        $playerRoles = array();

        $query = new EntityFieldQuery();

        $query->entityCondition('entity_type', 'taxonomy_term')
            ->entityCondition('bundle', 'team_roles')

            ->addMetaData('account', user_load(1)); // Run the query as user 1.

        $result = $query->execute();

        if (!empty($result['taxonomy_term'])) {
            $roles = taxonomy_term_load_multiple(array_keys($result['taxonomy_term']));
        }

        //add to array using term id for index and term name for value
        foreach ($roles as $role) {
            //dpm($role);
            $playerRoles[$role->tid] = $role->name;
        }


        return $playerRoles;

    } catch (Exception $e) {
        _watchdog_log($e->getMessage());
    }

}

function getMapsByTitleAndMode($gameTitle, $gameMode){
    try{
        //
        $gameMaps = array();
        $query = new EntityFieldQuery();

        $query->entityCondition('entity_type', 'taxonomy_term')
            ->entityCondition('bundle', 'maps_advanced_warfare')
            ->fieldCondition('field_ref_map_game', 'target_id', $gameTitle, '=')
            ->fieldCondition('field_ref_map_mode', 'target_id', $gameMode, '=')

            ->addMetaData('account', user_load(1)); // Run the query as user 1.

        $result = $query->execute();


        if (!empty($result['taxonomy_term'])) {
            $maps = taxonomy_term_load_multiple(array_keys($result['taxonomy_term']));
        }

        //add to array using term id for index and term name for value
        foreach ($maps as $map) {
            //dpm($role);
            $gameMaps[$map->tid] = $map->name;
        }

        return $gameMaps;

    } catch (Exception $e) {
        _watchdog_log($e->getMessage());
    }
}

function getChallongeTournamentIDByNodeID($tournamentNID){
    //get challonge tourney ID from NID
    return GetWrapperByEntityID($tournamentNID)->field_tournament_challonge_id->value();
}

function getChallongeMatchIDByNodeID($matchNID){

    //get challonge tourney ID from NID
    return GetWrapperByEntityID($matchNID)->field_match_challonge_id->value();
}

/**
 * @param $tournamentID
 * @param $teamName
 * @param $currentUser
 */
function createTeamAndAddToTournament($tournamentID, $teamName, &$currentUser, $createTeam){
    include_once DRUPAL_ROOT . '/includes/challonge.class.php';

    //debug logging
    _watchdog_log('createTeamAndAddToTournament:', 'tid: '. $tournamentID . 'team name: ' .  $teamName . 'current uid' . $currentUser->uid . 'create team' .  $createTeam);

    //instantiate challonge API
    $c = new ChallongeAPI('XqrMnBPs15MvmX0izddB4zyIHKswRCoaIAyq4cTt');

    //if team is new create first then add to tournament, else just add to tournament
    if($createTeam) {
        try {

            //1. create and add team to team node

            //$tournament_id = ? //TODO:get current tourney ID context from variable, or url param
            //$currentuser = $GLOBALS['user'];

            $newTeamNode = new stdClass();
            $newTeamNode->type = 'team';
            $newTeamNode->title = $teamName;

            // Set the language.
            $newTeamNode->language = LANGUAGE_NONE;

            // Prepare and save the node.
            node_object_prepare($newTeamNode);
            $newTeamNode = node_submit($newTeamNode);
            $newTeamNode->revision = TRUE;
            node_save($newTeamNode);

            //print $newTeamNode->nid;
            //
            //wrap it
            $wrapper = GetWrapperByEntityID($newTeamNode->nid);//entity_metadata_wrapper('node', $newTeamNode);

            // USE TO ADD ENTITY REFERENCE BY NODE ID
            $wrapper->field_team_captain = $currentUser->uid;

            //generate random GFC team ID
            $teamID = (string)uniqid();

            //add team name
            $wrapper->field_team_name->set($teamName);
            $wrapper->field_team_id->set($teamID);

            $wrapper->save();

            //exception handler
        } catch (Exception $e) {
            _watchdog_log($e->getMessage());
        }

        //2. add user to team members as Captain

        try {

            //AddPlayerToTeam($newTeamNode->nid, $currentUser->uid, CAPTAIN_ROLE, 1);

            //THE FOLLOWING IS NOW ITS OWN FUNCTION {AddPlayerToTeam} SO THAT PLAYERS CAN JOIN TEAMS INDEPENDENTLY
            //create team members entity and wrap it
            $entity = entity_create('team_members', array('type' => 'team_members'));
            $emw = entity_metadata_wrapper('team_members', $entity);

            //set field values
            $emw->field_team_reference_from_team_m = $newTeamNode->nid;
            $emw->field_team_member_role = CAPTAIN_ROLE; //captain taxonomy ID TODO, need to get this dynamically
            $emw->field_team_member_user = $currentUser->uid;

            //denote that team creator entry is not provisional so mark as confirmed
            $emw->field_team_member_entry_confirme = 1;


            //save it out
            $emw->save();

            //debug code
            _watchdog_log('createTeamAndAddToTournament: user: ' . $currentUser->uid . ' added as Captain to team ' .$newTeamNode->nid) ;


            //exception handler
        } catch (Exception $e) {
            _watchdog_log($e->getMessage(),$e);
        }


    }

    //***3. add team to tournament
    //***NOTE: this step applies whether team is new OR existing

    //if existing team, use the NID parameter
    if(!$createTeam)
    {
        $teamNID = $teamName;
    }
    else
    {
        $teamNID = $newTeamNode->nid;
    }

    try {
        //$tourneynode = node_load($tournamentID); //depends on tourney id being available
        $emwtourney = GetWrapperByEntityID($tournamentID);   //entity_metadata_wrapper('node',$tourneynode);
        $emwtourney->field_tournament_teams_entered[] = $teamNID;

        //save it out
        $emwtourney->save();

        //log if this worked
//        _watchdog_log('adding team to tourney:' . print_r($emwtourney));

        //debug logging
        _watchdog_log('createTeamAndAddToTournament: added to tourney team ' . $teamNID);

        //exception handler
    } catch (Exception $e) {

        _watchdog_log($e->getMessage());

    }


//4. add team to Challonge.

    try {

        //set team name variable
        if($createTeam){
            $teamName = $wrapper->field_team_name->value();
            $teamID = $wrapper->field_team_id->value();
        }
        else
        {
            $teamName = GetWrapperByEntityID($teamNID)->field_team_name->value();
            $teamID = GetWrapperByEntityID($teamNID)->field_team_id->value();

        }

        $tournament_challonge_id = (string)$emwtourney->field_tournament_challonge_id->value();
        $params = array(
            "participant[name]" => $teamName,
            "participant[seed]" => "1",
            "participant[misc]" => $teamID
        );

        $participant = $c->makeCall("tournaments/$tournament_challonge_id/participants", $params, "post");
        $participant = $c->createParticipant($tournament_challonge_id, $params);

        //debug logging
        _watchdog_log('Challonge request made for team: ' . $teamName . ' id=' . $teamID . ' in tourney:' . $tournament_challonge_id,$c->result);


        //generic function indicator message for test only
        drupal_set_message(t('Your team has been successfully entered in this tournament.'));

        return $teamNID;

//exception handler
    } catch (Exception $e) {
        _watchdog_log($e->getMessage());
    }



    //        return $newTeamNode->nid;

}
function LookupPlayerByAttribute($attributeValue){

    //input must NOT be an empty string

    //OPTION 1. by EMAIL
    //check if valid email and if so look up for user
    if(filter_var($attributeValue, FILTER_VALIDATE_EMAIL)){
        $invitedUser = user_load_by_mail($attributeValue);
        //if user exists return uid, else return 0 indicating they don't exist
        if($invitedUser){
            return $invitedUser->uid;
        }
        else{
            return null;
        }
    }

    //OPTION 2. By Username
    //user_load_by_name($attributeValue)
    $invitedUser = user_load_by_name($attributeValue);
    //if user exists return uid, else return 0 indicating they don't exist
    if($invitedUser){
        return $invitedUser->uid;
    }


    //OPTION 3. lookup by PS handle
    $query = new EntityFieldQuery();
    $query->entityCondition('entity_type', 'user')
        ->fieldCondition('field_gamertag', 'value', $attributeValue);

    $result = $query->execute();
    $users_ids = array_keys($result['user']);

    if($users_ids){

        return $users_ids[0];
    }

    //If NOTHING works then return 0
    return null;
}

function AddPlayerToTeam($teamID, $userID, $roleID, $inviteAccepted){
    //add player to tournament. When invited set inviteAccepted to 0 until player acknowledges they wish to join.

    try {

        //create team members entity and wrap it
        $entity = entity_create('team_members', array('type' => 'team_members'));
        $emw = entity_metadata_wrapper('team_members', $entity);

        //set field values
        $emw->field_team_reference_from_team_m = $teamID;
        $emw->field_team_member_role = $roleID; //captain taxonomy ID TODO, need to get this dynamically
        $emw->field_team_member_user = $userID;

        if($inviteAccepted){
            $emw->field_team_member_entry_confirme = $inviteAccepted;
        }


        //save it out
        $emw->save();

        //exception handler
    } catch (Exception $e) {
        _watchdog_log($e->getMessage());
    }


}

function RemovePlayerFromTeam($entityID){

    /*
     *
     *
     * Remove a player from the team
     * If the player happens to have accepted invite...
     * that's okay because when tournament starts
     * only those in the team (having status ACTIVE) at the MOMENT it starts will have their credits removed permanently
     *
     *
     * */


    try {

        $emw = entity_metadata_wrapper('team_members', $entityID);
        $emw->field_team_member_status = MEMBER_REMOVED_STATUS;
        $emw->save();


        //code to actually delete member
        //entity_delete('team_members', $entityID);

        //exception handler
    } catch (Exception $e) {
        _watchdog_log($e->getMessage());
    }


}

function gfc_session($key, $value = NULL) {
    static $storage;
    if ($value) {
        $storage[$key] = $value ;
        $_SESSION['gfc'][$key] = $value ;   // I use 'lists' in case some other module uses 'type' in $_SESSION
    }
    else if (empty($storage[$key]) && isset($_SESSION['gfc'][$key])) {
        $storage[$key] = $_SESSION['gfc'][$key];
    }
    return $storage[$key];


    /*EXAMPLE
     *
     * gfc_session("s_key", "value");

    $myVar = gfc_session("s_key");

    print $myVar;
     *
     * */
}

function StartTournamentButtonContextBased($user,$tournamentID){


    $roleid = 3; //admin role
    $output = '';

    if(user_has_role($roleid, $user)) {
    //yes this user has this role, now check tournament status

        //check for tournament status
        if(strlen($tournamentID) > 12) {
            $touramentNID = getTournamentNodeIDByChallongeID($tournamentID);


            $w = GetWrapperByEntityID($touramentNID);

            if ($w->field_tournament_status->value() == 'Pending') {

                //load the start button form
                $block = block_load('Manage_Tournaments', 'Manage_Tournaments_Form_Block');
                $output = drupal_render(_block_get_renderable_array(_block_render_blocks(array($block))));


            }
        }

        return $output;

    }


}